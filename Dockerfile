# ======= Этап 1: Сборка приложения =======

# Используем официальный образ Go с конкретной версией для стабильности сборки
# builder - это задание имени для стадии сборки (stage name).
FROM golang:1.25.0 AS builder 

# Устанавливаем рабочую директорию внутри контейнера
WORKDIR /app 

# Копируем файлы go.mod и go.sum отдельно для кеширования зависимостей
COPY go.mod go.sum ./

# Загружаем зависимости заранее.
# Вытаскиваем их из go.mod и проверяем hash при помощи go.sum 
RUN go mod download

# Копируем весь исходный код приложения в папку /app внутри контейнера
COPY ./app ./ 

# Собираем статически слинкованный бинарник для Alpine без Clib, бинарник для linux
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o server .

# ======= Этап 2: Минимальный образ для запуска приложения =======

# Используем минимальный стабильный образ Alpine Linux для финального контейнера
FROM alpine:3.21.3

# Устанавливаем рабочую директорию внутри контейнера
WORKDIR /app 

# Копируем готовый бинарник из стадии сборки
COPY --from=builder /app/server ./ 

# EXPOSE — это лишь мета-информация для документации образа.
# Она сообщает, что приложение внутри контейнера слушает на порту 7000.
# EXPOSE сам по себе не открывает порт для внешнего мира!
# Чтобы порт стал доступен снаружи, при запуске контейнера нужно явно указать флаг -p:
# docker run -p 8080:7000 my-go-server
EXPOSE 7000 

# Устанавливаем команду по умолчанию для запуска контейнера
CMD ["./server"]

